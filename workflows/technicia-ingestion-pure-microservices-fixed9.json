{
  "name": "TechnicIA - Workflow d'Ingestion 100% Microservices (Fixed 9)",
  "nodes": [
    {
      "parameters": {
        "path": "upload",
        "responseMode": "lastNode",
        "options": {
          "binaryData": true,
          "bodyContentType": "multipart/form-data"
        },
        "httpMethod": "POST"
      },
      "name": "Document Upload Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [240, 300],
      "webhookId": "upload"
    },
    {
      "parameters": {
        "jsCode": "// Récupération des informations du fichier uploadé et validation basique\nconst documentId = 'doc-' + Date.now();\nlet errors = [];\nlet binaryData = null;\nlet fileName = 'document.pdf';\nlet fileSize = 0;\nlet binaryProperty = null;\n\n// Vérifier si nous avons reçu un fichier\nif ($input.item && $input.item.binary) {\n  const keys = Object.keys($input.item.binary);\n  if (keys.length > 0) {\n    binaryProperty = keys[0]; // Sauvegarde de la clé binaire\n    const fileData = $input.item.binary[keys[0]];\n    if (fileData) {\n      binaryData = fileData;\n      fileName = fileData.fileName || 'document.pdf';\n      fileSize = fileData.fileSize || 0;\n      \n      // Assurons-nous que le nom de fichier a l'extension .pdf\n      if (!fileName.toLowerCase().endsWith('.pdf')) {\n        fileName += '.pdf';\n      }\n      \n      // Vérification de la taille maximale (200 Mo)\n      const MAX_SIZE = 200 * 1024 * 1024;\n      if (fileSize > MAX_SIZE) {\n        errors.push(`Le fichier est trop volumineux (${Math.round(fileSize / (1024 * 1024))} Mo). Maximum autorisé: 200 Mo`);\n      }\n    } else {\n      errors.push('Données de fichier invalides');\n    }\n  } else {\n    errors.push('Aucune donnée binaire trouvée');\n  }\n} else {\n  errors.push('Aucun fichier n\\'a été téléchargé');\n}\n\n// Informations de base pour le débogage\nconsole.log('Détails du fichier:', { \n  fileName, \n  fileSize: fileSize ? (fileSize / (1024 * 1024)).toFixed(2) + ' MB' : 'N/A' \n});\n\n// Configuration globale avec les endpoints corrects basés sur le code source\nconst config = {\n  // Utiliser directement /tmp qui existe déjà sur presque tous les systèmes\n  storageFolder: '/tmp/',\n  // URLs correctes basées sur le code source\n  documentProcessorUrl: 'http://technicia-document-processor:8000/process',\n  schemaAnalyzerUrl: 'http://technicia-vision-classifier:8000/classify',\n  vectorEngineUrl: 'http://technicia-vector-store:8000',\n  environment: 'production',\n  version: '1.0.0'\n};\n\n// Créer le chemin complet du fichier - Plus simple\nconst uniqueFileName = documentId + '-' + fileName;\nconst fullPath = config.storageFolder + uniqueFileName;\n\n// Récupérer les données binaires pour les passer au prochain nœud\nconst inputBinary = $input.item.binary || {};\n\n// Résultat validé\nreturn {\n  json: {\n    documentId,\n    fileName,\n    uniqueFileName,\n    fileSize,\n    mimeType: 'application/pdf', // On force le type MIME à PDF\n    errors,\n    isValid: errors.length === 0,\n    timestamp: new Date().toISOString(),\n    // Données binaires\n    binaryProperty, // La variable est maintenant définie en dehors des conditions\n    // Chemins\n    storageFolder: config.storageFolder,\n    fullPath,\n    // URLs microservices\n    documentProcessorUrl: config.documentProcessorUrl,\n    schemaAnalyzerUrl: config.schemaAnalyzerUrl,\n    vectorEngineUrl: config.vectorEngineUrl\n  },\n  // Passer les données binaires telles quelles\n  binary: inputBinary\n};"
      },
      "name": "Validate and Configure",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [420, 300]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.isValid }}",
              "value2": true
            }
          ]
        }
      },
      "name": "Document Valid?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [600, 300]
    },
    {
      "parameters": {
        "jsCode": "// Renommer les données binaires pour qu'elles soient accessibles sous le nom 'data'\nconst output = {};\n\n// Copier toutes les propriétés JSON\noutput.json = {...$input.item.json};\n\n// Préparer l'objet binaire\noutput.binary = {};\n\n// Vérifier si des données binaires sont disponibles\nif ($input.item.binary) {\n  const binaryKeys = Object.keys($input.item.binary);\n  \n  if (binaryKeys.length > 0) {\n    // Récupérer les données binaires de la première clé disponible\n    const firstBinaryKey = binaryKeys[0];\n    \n    // Assigner ces données à la clé 'data' pour le nœud Write Binary File\n    output.binary.data = $input.item.binary[firstBinaryKey];\n    \n    console.log(`Données binaires renommées: ${firstBinaryKey} -> data`);\n  } else {\n    console.log('Aucune donnée binaire disponible à renommer');\n  }\n}\n\nreturn output;"
      },
      "name": "Rename Binary Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [760, 300]
    },
    {
      "parameters": {
        "fileName": "={{ $json.fullPath }}",
        "options": {}
      },
      "name": "Write Binary File",
      "type": "n8n-nodes-base.writeBinaryFile",
      "typeVersion": 1,
      "position": [920, 300]
    },
    {
      "parameters": {
        "url": "={{ $json.documentProcessorUrl }}",
        "method": "POST",
        "authentication": "none",
        "sendHeaders": true,
        "contentType": "multipart-form-data",
        "bodyParameters": {
          "parameters": []
        },
        "bodyFormData": {
          "formData": [
            {
              "parameterType": "formBinaryData",
              "parameterName": "file",
              "inputDataFieldName": "data",
              "contentType": "application/pdf"
            }
          ]
        },
        "options": {
          "proxy": "",
          "timeout": 0,
          "allowUnauthorizedCerts": true,
          "bodyContentType": "multipart-form-data",
          "response": {
            "response": {
              "fullResponse": true
            }
          }
        }
      },
      "name": "Document Processor Service",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [1080, 300]
    },
    {
      "parameters": {
        "jsCode": "// Préparation de l'analyse des schémas\n// Récupérer les résultats du Document Processor\nconst docProcessorResults = $json.body || {};\nconsole.log('Document Processor Results:', JSON.stringify(docProcessorResults, null, 2));\n\n// Vérifier si le Document Processor a bien fonctionné\nif (!docProcessorResults.document_id) {\n  throw new Error(`Document Processor failed: ${JSON.stringify(docProcessorResults)}`);\n}\n\n// Récupérer les données du document\nconst documentInfo = $input.item.json;\n\n// Extraire les informations nécessaires\nconst documentId = documentInfo.documentId;\nconst extractedImages = docProcessorResults.images || [];\nconst storageFolder = documentInfo.storageFolder;\n\nreturn {\n  json: {\n    // Paramètres du document\n    documentId,\n    storageFolder,\n    // URLs microservices\n    schemaAnalyzerUrl: documentInfo.schemaAnalyzerUrl,\n    vectorEngineUrl: documentInfo.vectorEngineUrl,\n    // Données extraites par Document Processor\n    images: extractedImages.map(img => ({\n      id: img.id,\n      path: img.path,\n      page: img.page || 0,\n      width: img.width || 0,\n      height: img.height || 0\n    })),\n    textBlocks: docProcessorResults.pages?.flatMap(page => \n      page.paragraphs.map(para => ({\n        text: para.text,\n        page: page.page_number,\n        confidence: para.confidence\n      }))\n    ) || [],\n    pageCount: docProcessorResults.page_count || 0,\n    metadata: {\n      filename: documentInfo.fileName,\n      mimetype: documentInfo.mimeType,\n      documentId: documentId\n    },\n    // Autres informations\n    fileName: documentInfo.fileName,\n    fullPath: documentInfo.fullPath,\n    timestamp: new Date().toISOString()\n  }\n};"
      },
      "name": "Process Document Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1240, 300]
    },
    {
      "parameters": {
        "url": "={{ $json.schemaAnalyzerUrl }}",
        "method": "POST",
        "authentication": "none",
        "sendHeaders": true,
        "contentType": "multipart-form-data",
        "bodyParameters": {
          "parameters": []
        },
        "bodyFormData": {
          "formData": [
            {
              "parameterType": "formParameter",
              "parameterName": "images",
              "parameterValue": "={{ JSON.stringify($json.images) }}",
              "contentType": "application/json"
            }
          ]
        },
        "options": {
          "proxy": "",
          "timeout": 0,
          "allowUnauthorizedCerts": true,
          "response": {
            "response": {
              "fullResponse": true
            }
          }
        }
      },
      "name": "Schema Analyzer Service",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [1400, 300]
    },
    {
      "parameters": {
        "jsCode": "// Traitement des résultats de Schema Analyzer\nconst analyzerResults = $json.body || {};\nconsole.log('Schema Analyzer Results:', JSON.stringify(analyzerResults, null, 2));\n\n// Vérifier si le Schema Analyzer a bien fonctionné\nif (!analyzerResults.success && !analyzerResults.images) {\n  throw new Error(`Schema Analyzer failed: ${JSON.stringify(analyzerResults)}`);\n}\n\n// Récupérer les données du document\nconst documentInfo = $input.item.json;\n\n// Extraire les informations nécessaires\nconst documentId = documentInfo.documentId;\nconst textBlocks = documentInfo.textBlocks;\nconst pageCount = documentInfo.pageCount;\nconst metadata = documentInfo.metadata;\nconst processedImages = documentInfo.images || [];\n\n// Classifier les images en utilisant les résultats\nconst classifiedImages = processedImages.map(img => {\n  // Trouver les résultats de classification pour cette image\n  const classification = analyzerResults.images?.find(res => res.id === img.id);\n  \n  return {\n    ...img,\n    classification: classification?.is_technical_diagram ? 'technical_diagram' : 'decorative',\n    schema_type: classification?.schema_type || 'unknown',\n    confidence: classification?.confidence || 0,\n    ocrText: classification?.detected_text || ''\n  };\n});\n\n// Statistiques sur les images\nconst stats = {\n  totalImages: classifiedImages.length,\n  technicalDiagrams: classifiedImages.filter(img => img.classification === 'technical_diagram').length,\n  decorativeImages: classifiedImages.filter(img => img.classification !== 'technical_diagram').length,\n  imagesWithText: classifiedImages.filter(img => img.ocrText && img.ocrText.length > 0).length\n};\n\n// Préparation des données pour Vector Engine\nreturn {\n  json: {\n    documentId,\n    vectorEngineUrl: documentInfo.vectorEngineUrl,\n    textBlocks,\n    images: classifiedImages,\n    metadata: {\n      ...metadata,\n      pageCount,\n      imageStats: stats\n    },\n    fileName: documentInfo.fileName,\n    fullPath: documentInfo.fullPath,\n    timestamp: new Date().toISOString()\n  }\n};"
      },
      "name": "Process Schema Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1560, 300]
    },
    {
      "parameters": {
        "url": "={{ $json.vectorEngineUrl }}/embed-text",
        "method": "POST",
        "authentication": "none",
        "sendHeaders": true,
        "contentType": "json",
        "bodyParameters": {
          "parameters": [
            {
              "name": "text",
              "value": "={{ $json.textBlocks[0]?.text || 'Texte vide' }}"
            },
            {
              "name": "metadata",
              "value": "={{ { documentId: $json.documentId } }}"
            }
          ]
        },
        "options": {
          "proxy": "",
          "timeout": 0,
          "allowUnauthorizedCerts": true,
          "response": {
            "response": {
              "fullResponse": true
            }
          }
        }
      },
      "name": "Vector Engine Service",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [1720, 300]
    },
    {
      "parameters": {
        "jsCode": "// Préparation des statistiques et de la réponse finale\nconst vectorEngineResults = $json.body || {};\nconsole.log('Vector Engine Results:', JSON.stringify(vectorEngineResults, null, 2));\n\n// Vérifier si le Vector Engine a bien fonctionné\nif (!vectorEngineResults.id && !vectorEngineResults.status === 'success') {\n  throw new Error(`Vector Engine failed: ${JSON.stringify(vectorEngineResults)}`);\n}\n\n// Récupérer les informations\nconst documentInfo = $input.item.json;\nconst documentId = documentInfo.documentId;\nconst fileName = documentInfo.fileName;\nconst metadata = documentInfo.metadata || {};\nconst imageStats = metadata.imageStats || {};\n\n// Statistiques simplifiées\nconst vectorStats = {\n  totalTextBlocks: documentInfo.textBlocks?.length || 0,\n  chunksCount: 1, // Nous n'avons vectorisé qu'un seul bloc de texte pour le moment\n  indexedCount: vectorEngineResults.id ? 1 : 0\n};\n\nreturn {\n  json: {\n    success: true,\n    documentId,\n    fileName,\n    processingCompleted: true,\n    timestamp: new Date().toISOString(),\n    stats: {\n      textBlocksCount: vectorStats.totalTextBlocks,\n      chunksCreated: vectorStats.chunksCount,\n      vectorsIndexed: vectorStats.indexedCount,\n      imagesCount: imageStats.totalImages || 0,\n      technicalDiagramsCount: imageStats.technicalDiagrams || 0,\n      pageCount: metadata.pageCount || 0\n    },\n    microservicesUsed: {\n      documentProcessor: true,\n      schemaAnalyzer: true,\n      vectorEngine: true\n    },\n    status: 'indexed',\n    retrievalReady: true,\n    searchUrl: null\n  }\n};"
      },
      "name": "Prepare Final Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1880, 300]
    },
    {
      "parameters": {
        "url": "http://technicia-frontend:80/api/notifications",
        "method": "POST",
        "authentication": "none",
        "sendHeaders": true,
        "contentType": "json",
        "bodyParameters": {
          "parameters": [
            {
              "name": "type",
              "value": "document_processed"
            },
            {
              "name": "documentId",
              "value": "={{ $json.documentId }}"
            },
            {
              "name": "fileName",
              "value": "={{ $json.fileName }}"
            },
            {
              "name": "stats",
              "value": "={{ $json.stats }}"
            },
            {
              "name": "status",
              "value": "={{ $json.status }}"
            }
          ]
        },
        "options": {
          "proxy": "",
          "timeout": 0,
          "allowUnauthorizedCerts": true
        }
      },
      "name": "Notify Frontend",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [2040, 300]
    },
    {
      "parameters": {
        "content": "={{ JSON.stringify({success: true, document_id: $json.documentId, status: 'processing', message: 'Document accepté et en cours de traitement'}) }}",
        "responseProperties": {
          "properties": [
            {
              "name": "responseCode",
              "value": 200
            }
          ]
        }
      },
      "name": "Send Response Success",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [760, 160]
    },
    {
      "parameters": {
        "content": "={{ JSON.stringify({ success: false, errors: $json.errors }) }}",
        "responseProperties": {
          "properties": [
            {
              "name": "responseCode",
              "value": 400
            }
          ]
        }
      },
      "name": "Send Response Error",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [760, 520]
    },
    {
      "parameters": {
        "path": "health",
        "responseMode": "onReceived",
        "options": {},
        "httpMethod": "GET"
      },
      "name": "Health Check Endpoint",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [240, 520],
      "webhookId": "health"
    },
    {
      "parameters": {
        "jsCode": "// Vérification de l'état des microservices\n\nconst microserviceUrls = {\n  documentProcessor: 'http://technicia-document-processor:8000/health',\n  schemaAnalyzer: 'http://technicia-vision-classifier:8000/health',\n  vectorEngine: 'http://technicia-vector-store:8000/health'\n};\n\n// Fonction pour vérifier l'état d'un microservice\nasync function checkServiceHealth(url) {\n  try {\n    const response = await $http.get(url);\n    return response.status === 200 ? 'operational' : 'degraded';\n  } catch (error) {\n    return 'unavailable';\n  }\n}\n\n// Vérification de l'état de tous les services (en parallèle)\nconst documentProcessorStatus = await checkServiceHealth(microserviceUrls.documentProcessor);\nconst schemaAnalyzerStatus = await checkServiceHealth(microserviceUrls.schemaAnalyzer);\nconst vectorEngineStatus = await checkServiceHealth(microserviceUrls.vectorEngine);\n\n// Déterminer l'état global du système\nconst allOperational = (\n  documentProcessorStatus === 'operational' &&\n  schemaAnalyzerStatus === 'operational' &&\n  vectorEngineStatus === 'operational'\n);\n\nconst anyUnavailable = (\n  documentProcessorStatus === 'unavailable' ||\n  schemaAnalyzerStatus === 'unavailable' ||\n  vectorEngineStatus === 'unavailable'\n);\n\nconst systemStatus = allOperational ? 'operational' : (anyUnavailable ? 'service_outage' : 'degraded');\n\nreturn {\n  json: {\n    status: systemStatus,\n    service: 'TechnicIA Document Ingestion',\n    version: '2.0.0',\n    timestamp: new Date().toISOString(),\n    microservices: {\n      documentProcessor: documentProcessorStatus,\n      schemaAnalyzer: schemaAnalyzerStatus,\n      vectorEngine: vectorEngineStatus\n    }\n  }\n};"
      },
      "name": "Check Microservices Health",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [420, 520]
    },
    {
      "parameters": {
        "content": "={{ JSON.stringify($json) }}",
        "responseProperties": {
          "properties": [
            {
              "name": "responseCode",
              "value": "={{ $json.status === 'operational' ? 200 : ($json.status === 'degraded' ? 503 : 500) }}"
            }
          ]
        }
      },
      "name": "Return Health Status",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [600, 520]
    },
    {
      "parameters": {
        "path": "document/:documentId/status",
        "responseMode": "onReceived",
        "options": {},
        "httpMethod": "GET"
      },
      "name": "Document Status Endpoint",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [240, 700],
      "webhookId": "document-status"
    },
    {
      "parameters": {
        "url": "={{ 'http://technicia-vector-store:8000/search?documentId=' + $parameter.documentId }}",
        "method": "GET",
        "options": {
          "allowUnauthorizedCerts": true,
          "response": {
            "response": {
              "fullResponse": true
            }
          }
        }
      },
      "name": "Get Document Status",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 2,
      "position": [420, 700]
    },
    {
      "parameters": {
        "content": "={{ JSON.stringify($json.body || {error: 'Unable to retrieve document status'}) }}",
        "responseProperties": {
          "properties": [
            {
              "name": "responseCode",
              "value": "={{ $json.statusCode || 200 }}"
            }
          ]
        }
      },
      "name": "Return Document Status",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [600, 700]
    }
  ],
  "connections": {
    "Document Upload Webhook": {
      "main": [
        [
          {
            "node": "Validate and Configure",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate and Configure": {
      "main": [
        [
          {
            "node": "Document Valid?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Document Valid?": {
      "main": [
        [
          {
            "node": "Rename Binary Data",
            "type": "main",
            "index": 0
          },
          {
            "node": "Send Response Success",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Send Response Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Rename Binary Data": {
      "main": [
        [
          {
            "node": "Write Binary File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Write Binary File": {
      "main": [
        [
          {
            "node": "Document Processor Service",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Document Processor Service": {
      "main": [
        [
          {
            "node": "Process Document Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Document Results": {
      "main": [
        [
          {
            "node": "Schema Analyzer Service",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Schema Analyzer Service": {
      "main": [
        [
          {
            "node": "Process Schema Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Schema Results": {
      "main": [
        [
          {
            "node": "Vector Engine Service",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Vector Engine Service": {
      "main": [
        [
          {
            "node": "Prepare Final Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Final Response": {
      "main": [
        [
          {
            "node": "Notify Frontend",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Health Check Endpoint": {
      "main": [
        [
          {
            "node": "Check Microservices Health",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Microservices Health": {
      "main": [
        [
          {
            "node": "Return Health Status",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Document Status Endpoint": {
      "main": [
        [
          {
            "node": "Get Document Status",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Document Status": {
      "main": [
        [
          {
            "node": "Return Document Status",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  }
}