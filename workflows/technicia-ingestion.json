{
  "name": "TechnicIA Document Ingestion",
  "nodes": [
    {
      "parameters": {
        "path": "upload",
        "responseMode": "responseNode",
        "options": {
          "binaryData": true,
          "bodyContentType": "multipart-form-data"
        },
        "httpMethod": "POST"
      },
      "name": "Document Upload Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        240,
        300
      ],
      "webhookId": "upload"
    },
    {
      "parameters": {
        "jsCode": "// Récupération et validation du fichier PDF\nconst result = {};\n\ntry {\n  // 1. Vérifier la présence de données binaires\n  if (!$input.item.binary) {\n    throw new Error('Aucune donnée binaire reçue');\n  }\n  \n  // 2. Trouver la propriété contenant le fichier (doit être 'file' selon le frontend)\n  let binaryPropertyName = null;\n  const binaryProperties = Object.keys($input.item.binary);\n  \n  // Le frontend utilise la clé 'file' dans FormData.append('file', fileObj.file)\n  if (binaryProperties.includes('file')) {\n    binaryPropertyName = 'file';\n  } else {\n    // Fallback: utiliser la première propriété disponible\n    binaryPropertyName = binaryProperties[0];\n  }\n  \n  if (!binaryPropertyName) {\n    throw new Error('Aucune propriété binaire trouvée');\n  }\n  \n  // 3. Extraire les informations sur le fichier\n  const fileData = $input.item.binary[binaryPropertyName];\n  \n  // Logging complet pour le débogage\n  console.log('Propriétés du fichier reçu:', JSON.stringify({\n    fileName: fileData.fileName,\n    mimeType: fileData.mimeType,\n    fileSize: fileData.fileSize,\n    fileExtension: fileData.fileName ? fileData.fileName.split('.').pop().toLowerCase() : null,\n    binaryPropertyName: binaryPropertyName\n  }, null, 2));\n  \n  // 4. Validation du type de fichier - PLUS SOUPLE\n  const isPdf = \n    // Vérifier le type MIME\n    (fileData.mimeType && fileData.mimeType.toLowerCase().includes('pdf')) ||\n    // Vérifier aussi l'extension du fichier comme plan B\n    (fileData.fileName && fileData.fileName.toLowerCase().endsWith('.pdf'));\n  \n  if (!isPdf) {\n    console.error('Type de fichier non supporté:', fileData.mimeType);\n    throw new Error('Le fichier doit être au format PDF (.pdf)');\n  }\n  \n  // 5. Extraire les métadonnées\n  const fileName = fileData.fileName || 'document.pdf';\n  const fileSize = fileData.fileSize || 0;\n  \n  // 6. Logging des métadonnées\n  console.log('Fichier validé:', fileName);\n  console.log('Taille:', fileSize, 'octets');\n  \n  // 7. Préparer le résultat\n  result.fileName = fileName;\n  result.fileSize = fileSize;\n  result.mimeType = fileData.mimeType || 'application/pdf'; // Utiliser une valeur par défaut si non défini\n  result.binaryPropertyName = binaryPropertyName;\n  result.uploadTime = new Date().toISOString();\n  result.success = true;\n  \n  return result;\n  \n} catch (error) {\n  console.error('Erreur lors du traitement du fichier:', error.message);\n  return {\n    success: false,\n    error: error.message,\n    timestamp: new Date().toISOString()\n  };\n}"
      },
      "name": "Validate File",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [
        420,
        300
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.success }}",
              "value2": true
            }
          ]
        }
      },
      "name": "Validation OK?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        600,
        300
      ]
    },
    {
      "parameters": {
        "jsCode": "// Simulation de traitement de document pour contourner les problèmes potentiels avec le microserveur\n// Cela permet au frontend de fonctionner même si le microserveur Python n'est pas disponible\n\nconst inputData = $input.item.json;\n\n// Créer une réponse simulée qui correspond exactement à ce que le frontend attend\nconst result = {\n  success: true,\n  document_id: 'doc-' + Date.now(), // ID unique basé sur le timestamp\n  document_name: inputData.fileName || 'document.pdf',\n  text_chunks_count: 8, // Valeur simulée\n  images_count: 3, // Valeur simulée\n  processing_type: 'simulated',\n  processing_details: {\n    processing_time: 1.5, // Temps simulé\n    page_count: 12, // Nombre de pages simulé\n    mime_type: inputData.mimeType || 'application/pdf'\n  }\n};\n\n// Log pour le débogage\nconsole.log('Réponse simulée pour contourner les problèmes de microserveur:', JSON.stringify(result, null, 2));\n\nreturn result;"
      },
      "name": "Simulate Processing",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [
        780,
        300
      ]
    },
    {
      "parameters": {
        "content": "={{ JSON.stringify($json) }}",
        "options": {
          "responseCode": 200
        }
      },
      "name": "Return Success",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        960,
        300
      ]
    },
    {
      "parameters": {
        "content": "={{ JSON.stringify({\n  \"success\": false,\n  \"error\": $json.error || \"Une erreur est survenue lors du traitement\",\n  \"timestamp\": new Date().toISOString()\n}) }}",
        "options": {
          "responseCode": 400
        }
      },
      "name": "Return Error",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        780,
        400
      ]
    }
  ],
  "connections": {
    "Document Upload Webhook": {
      "main": [
        [
          {
            "node": "Validate File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate File": {
      "main": [
        [
          {
            "node": "Validation OK?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validation OK?": {
      "main": [
        [
          {
            "node": "Simulate Processing",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Return Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Simulate Processing": {
      "main": [
        [
          {
            "node": "Return Success",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {}
}