{
  "name": "TechnicIA - Workflow d'Ingestion 100% Microservices",
  "nodes": [
    {
      "parameters": {
        "path": "upload",
        "responseMode": "lastNode",
        "options": {
          "binaryData": true,
          "bodyContentType": "multipart/form-data"
        },
        "httpMethod": "POST"
      },
      "name": "Document Upload Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [240, 300],
      "webhookId": "upload"
    },
    {
      "parameters": {
        "jsCode": "// 1. Validation du document\nlet errors = [];\nlet documentId = 'doc-' + Date.now(); // ID unique pour ce document\nlet documentData = {};\n\n// Vérifier si nous avons reçu un fichier PDF\nif ($input.item && $input.item.binary) {\n  const keys = Object.keys($input.item.binary);\n  if (keys.length > 0) {\n    const fileData = $input.item.binary[keys[0]];\n    if (fileData) {\n      documentData = {\n        fileName: fileData.fileName || 'document.pdf',\n        mimeType: fileData.mimeType || '',\n        fileSize: fileData.fileSize || 0,\n        data: keys[0] // Clé d'accès à la donnée binaire\n      };\n      \n      // Vérification si le fichier est un PDF en examinant sa signature\n      if ($input.item.binary[documentData.data]) {\n        try {\n          // Convertir les données binaires en Buffer pour examen\n          const fileBuffer = Buffer.from($input.item.binary[documentData.data].data, 'base64');\n          // Vérifier si les premiers octets correspondent à la signature d'un PDF (%PDF-)\n          const pdfSignature = fileBuffer.slice(0, 5).toString();\n          const isPDF = pdfSignature === '%PDF-';\n          \n          if (!isPDF) {\n            errors.push('Le fichier doit être au format PDF (signature non valide: ' + pdfSignature + ')');\n          }\n        } catch (error) {\n          errors.push('Erreur lors de la vérification du format du fichier: ' + error.message);\n        }\n      } else {\n        errors.push('Données de fichier inaccessibles ou corrompues');\n      }\n      \n      // Vérification de la taille maximale (200 Mo)\n      const MAX_SIZE = 200 * 1024 * 1024;\n      if (documentData.fileSize > MAX_SIZE) {\n        errors.push(`Le fichier est trop volumineux (${Math.round(documentData.fileSize / (1024 * 1024))} Mo). Maximum autorisé: 200 Mo`);\n      }\n    } else {\n      errors.push('Données de fichier invalides');\n    }\n  } else {\n    errors.push('Aucune donnée binaire trouvée');\n  }\n} else {\n  errors.push('Aucun fichier n\\'a été téléchargé');\n}\n\n// Résultat de la validation\nreturn {\n  json: {\n    documentId: documentId,\n    fileName: documentData.fileName,\n    fileSize: documentData.fileSize,\n    mimeType: 'application/pdf', // Forcer le type MIME à PDF si la validation par signature a réussi\n    errors: errors,\n    isValid: errors.length === 0,\n    timestamp: new Date().toISOString(),\n    binaryDataKey: documentData.data || null\n  }\n};"
      },
      "name": "Validate Document",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [420, 300]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.isValid }}",
              "value2": true
            }
          ]
        }
      },
      "name": "Document Valid?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [600, 300]
    },
    {
      "parameters": {
        "jsCode": "// Configuration - serait normalement dans un fichier .env ou des credentials\nreturn {\n  json: {\n    storageFolder: '/tmp/technicia-docs/',\n    // URLs des microservices\n    documentProcessorUrl: 'http://document-processor:8001/api/process',\n    schemaAnalyzerUrl: 'http://schema-analyzer:8002/api/analyze',\n    vectorEngineUrl: 'http://vector-engine:8003/api/vectorize',\n    diagnosisEngineUrl: 'http://diagnosis-engine:8004/api/diagnose',\n    // Informations sur l'environnement\n    environment: 'production',\n    version: '1.0.0',\n    ...$input.item.json\n  }\n};"
      },
      "name": "Config Parameters",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [760, 300]
    },
    {
      "parameters": {
        "fileName": "={{ $node[\"Config Parameters\"].json.storageFolder + $json.documentId + '/' + $json.fileName }}",
        "binaryPropertyName": "={{ $json.binaryDataKey }}",
        "options": {
          "createParentPath": true
        }
      },
      "name": "Write Binary File",
      "type": "n8n-nodes-base.writeBinaryFile",
      "typeVersion": 1,
      "position": [760, 200]
    },
    {
      "parameters": {
        "jsCode": "// Préparer les données pour le traitement du document\n\n// Récupérer les données de configuration\nconst config = $node[\"Config Parameters\"].json;\n\n// Récupérer les données du document\nconst documentInfo = $node[\"Validate Document\"].json;\n\n// Récupérer les informations du fichier stocké\nconst storedFile = $input.item.json;\n\nreturn {\n  json: {\n    // Informations du document\n    documentId: documentInfo.documentId,\n    fileName: documentInfo.fileName,\n    filePath: storedFile.path || storedFile.fileName,\n    mimeType: documentInfo.mimeType,\n    fileSize: documentInfo.fileSize,\n    \n    // Données binaires pour le transfert (si besoin)\n    binaryDataKey: documentInfo.binaryDataKey,\n    \n    // Chemins complets\n    fullPath: config.storageFolder + documentInfo.documentId + '/' + documentInfo.fileName,\n    basePath: config.storageFolder + documentInfo.documentId + '/',\n    \n    // URLs des microservices\n    documentProcessorUrl: config.documentProcessorUrl,\n    schemaAnalyzerUrl: config.schemaAnalyzerUrl,\n    vectorEngineUrl: config.vectorEngineUrl,\n    \n    // Timestamp pour le suivi\n    timestamp: new Date().toISOString(),\n    \n    // Type de requête\n    requestType: 'document_ingestion'\n  }\n};"
      },
      "name": "Prepare Document Processing",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [940, 300]
    },
    {
      "parameters": {
        "url": "={{ $json.documentProcessorUrl }}",
        "method": "POST",
        "bodyContentType": "json",
        "bodyParameters": {
          "parameters": [
            {
              "name": "documentId",
              "value": "={{ $json.documentId }}"
            },
            {
              "name": "filePath",
              "value": "={{ $json.fullPath }}"
            },
            {
              "name": "fileName",
              "value": "={{ $json.fileName }}"
            },
            {
              "name": "mimeType",
              "value": "={{ $json.mimeType }}"
            },
            {
              "name": "outputPath",
              "value": "={{ $json.basePath }}"
            },
            {
              "name": "extractImages",
              "value": true
            },
            {
              "name": "extractText",
              "value": true
            }
          ]
        },
        "options": {
          "allowUnauthorizedCerts": true,
          "response": {
            "response": {
              "fullResponse": true
            }
          }
        }
      },
      "name": "Document Processor Service",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 2,
      "position": [1120, 300]
    },
    {
      "parameters": {
        "jsCode": "// Préparation de l'analyse des schémas\n// Récupérer les résultats du Document Processor\nconst docProcessorResults = $json.body || {};\n\n// Vérifier si le Document Processor a bien fonctionné\nif (!docProcessorResults.success) {\n  throw new Error(`Document Processor failed: ${docProcessorResults.message || 'Unknown error'}`);\n}\n\n// Extraire les informations nécessaires\nconst documentId = $node[\"Prepare Document Processing\"].json.documentId;\nconst extractedImages = docProcessorResults.images || [];\nconst basePath = $node[\"Prepare Document Processing\"].json.basePath;\n\n// Préparation des données pour Schema Analyzer\nreturn {\n  json: {\n    documentId: documentId,\n    schemaAnalyzerUrl: $node[\"Prepare Document Processing\"].json.schemaAnalyzerUrl,\n    images: extractedImages.map(img => ({\n      id: img.id,\n      path: img.path,\n      page: img.page,\n      width: img.width,\n      height: img.height\n    })),\n    basePath: basePath,\n    textBlocks: docProcessorResults.textBlocks || [],\n    pageCount: docProcessorResults.pageCount || 0,\n    metadata: docProcessorResults.metadata || {},\n    timestamp: new Date().toISOString()\n  }\n};"
      },
      "name": "Process Document Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1300, 300]
    },
    {
      "parameters": {
        "url": "={{ $json.schemaAnalyzerUrl }}",
        "method": "POST",
        "bodyContentType": "json",
        "bodyParameters": {
          "parameters": []
        },
        "bodyParametersJson": "={{ { \"documentId\": $json.documentId, \"images\": $json.images, \"basePath\": $json.basePath } }}",
        "options": {
          "allowUnauthorizedCerts": true,
          "response": {
            "response": {
              "fullResponse": true
            }
          }
        }
      },
      "name": "Schema Analyzer Service",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 2,
      "position": [1480, 300]
    },
    {
      "parameters": {
        "jsCode": "// Traitement des résultats de Schema Analyzer\nconst analyzerResults = $json.body || {};\n\n// Vérifier si le Schema Analyzer a bien fonctionné\nif (!analyzerResults.success) {\n  throw new Error(`Schema Analyzer failed: ${analyzerResults.message || 'Unknown error'}`);\n}\n\n// Récupérer les informations nécessaires\nconst documentId = $node[\"Process Document Results\"].json.documentId;\nconst textBlocks = $node[\"Process Document Results\"].json.textBlocks;\nconst pageCount = $node[\"Process Document Results\"].json.pageCount;\nconst metadata = $node[\"Process Document Results\"].json.metadata;\nconst processedImages = analyzerResults.images || [];\n\n// Statistiques sur les images\nconst stats = {\n  totalImages: processedImages.length,\n  technicalDiagrams: processedImages.filter(img => img.classification === 'technical_diagram').length,\n  decorativeImages: processedImages.filter(img => img.classification !== 'technical_diagram').length,\n  imagesWithText: processedImages.filter(img => img.ocrText && img.ocrText.length > 0).length\n};\n\n// Préparation des données pour Vector Engine\nreturn {\n  json: {\n    documentId: documentId,\n    vectorEngineUrl: $node[\"Prepare Document Processing\"].json.vectorEngineUrl,\n    textBlocks: textBlocks,\n    images: processedImages,\n    metadata: {\n      ...metadata,\n      pageCount: pageCount,\n      imageStats: stats\n    },\n    timestamp: new Date().toISOString()\n  }\n};"
      },
      "name": "Process Schema Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1660, 300]
    },
    {
      "parameters": {
        "url": "={{ $json.vectorEngineUrl }}/process",
        "method": "POST",
        "bodyContentType": "json",
        "bodyParameters": {
          "parameters": []
        },
        "bodyParametersJson": "={{ { \"documentId\": $json.documentId, \"textBlocks\": $json.textBlocks, \"images\": $json.images.filter(img => img.classification === 'technical_diagram'), \"metadata\": $json.metadata } }}",
        "options": {
          "allowUnauthorizedCerts": true,
          "response": {
            "response": {
              "fullResponse": true
            }
          }
        }
      },
      "name": "Vector Engine Service",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 2,
      "position": [1840, 300]
    },
    {
      "parameters": {
        "jsCode": "// Préparation des statistiques et de la réponse finale\nconst vectorEngineResults = $json.body || {};\n\n// Vérifier si le Vector Engine a bien fonctionné\nif (!vectorEngineResults.success) {\n  throw new Error(`Vector Engine failed: ${vectorEngineResults.message || 'Unknown error'}`);\n}\n\n// Récupérer les informations utiles pour la réponse\nconst documentId = $node[\"Process Schema Results\"].json.documentId;\nconst fileName = $node[\"Prepare Document Processing\"].json.fileName;\nconst pageCount = $node[\"Process Schema Results\"].json.metadata?.pageCount || 0;\nconst imageStats = $node[\"Process Schema Results\"].json.metadata?.imageStats || {};\n\n// Récupérer les statistiques du Vector Engine\nconst vectorStats = vectorEngineResults.stats || {};\n\nreturn {\n  json: {\n    success: true,\n    documentId: documentId,\n    fileName: fileName,\n    processingCompleted: true,\n    timestamp: new Date().toISOString(),\n    stats: {\n      textBlocksCount: vectorStats.totalTextBlocks || 0,\n      chunksCreated: vectorStats.chunksCount || 0,\n      vectorsIndexed: vectorStats.indexedCount || 0,\n      imagesCount: imageStats.totalImages || 0,\n      technicalDiagramsCount: imageStats.technicalDiagrams || 0,\n      pageCount: pageCount\n    },\n    microservicesUsed: {\n      documentProcessor: true,\n      schemaAnalyzer: true,\n      vectorEngine: true\n    },\n    status: 'indexed',\n    retrievalReady: true,\n    searchUrl: vectorEngineResults.searchEndpoint || null\n  }\n};"
      },
      "name": "Prepare Final Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [2020, 300]
    },
    {
      "parameters": {
        "url": "http://frontend:3000/api/notifications",
        "method": "POST",
        "bodyContentType": "json",
        "bodyParameters": {
          "parameters": [
            {
              "name": "type",
              "value": "document_processed"
            },
            {
              "name": "documentId",
              "value": "={{ $json.documentId }}"
            },
            {
              "name": "fileName",
              "value": "={{ $json.fileName }}"
            },
            {
              "name": "stats",
              "value": "={{ $json.stats }}"
            },
            {
              "name": "status",
              "value": "={{ $json.status }}"
            }
          ]
        },
        "options": {
          "allowUnauthorizedCerts": true
        }
      },
      "name": "Notify Frontend",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 2,
      "position": [2200, 300]
    },
    {
      "parameters": {
        "content": "={{ JSON.stringify({success: true, document_id: $json.documentId, status: 'processing', message: 'Document accepté et en cours de traitement'}) }}",
        "responseProperties": {
          "properties": [
            {
              "name": "responseCode",
              "value": 200
            }
          ]
        }
      },
      "name": "Send Response Success",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [940, 100]
    },
    {
      "parameters": {
        "content": "={{ JSON.stringify({ success: false, errors: $json.errors }) }}",
        "responseProperties": {
          "properties": [
            {
              "name": "responseCode",
              "value": 400
            }
          ]
        }
      },
      "name": "Send Response Error",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [760, 520]
    },
    {
      "parameters": {
        "path": "health",
        "responseMode": "onReceived",
        "options": {},
        "httpMethod": "GET"
      },
      "name": "Health Check Endpoint",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [240, 520],
      "webhookId": "health"
    },
    {
      "parameters": {
        "jsCode": "// Vérification de l'état des microservices\n\nconst microserviceUrls = {\n  documentProcessor: 'http://document-processor:8001/health',\n  schemaAnalyzer: 'http://schema-analyzer:8002/health',\n  vectorEngine: 'http://vector-engine:8003/health'\n};\n\n// Fonction pour vérifier l'état d'un microservice\nasync function checkServiceHealth(url) {\n  try {\n    const response = await $http.get(url);\n    return response.status === 200 ? 'operational' : 'degraded';\n  } catch (error) {\n    return 'unavailable';\n  }\n}\n\n// Vérification de l'état de tous les services (en parallèle)\nconst documentProcessorStatus = await checkServiceHealth(microserviceUrls.documentProcessor);\nconst schemaAnalyzerStatus = await checkServiceHealth(microserviceUrls.schemaAnalyzer);\nconst vectorEngineStatus = await checkServiceHealth(microserviceUrls.vectorEngine);\n\n// Déterminer l'état global du système\nconst allOperational = (\n  documentProcessorStatus === 'operational' &&\n  schemaAnalyzerStatus === 'operational' &&\n  vectorEngineStatus === 'operational'\n);\n\nconst anyUnavailable = (\n  documentProcessorStatus === 'unavailable' ||\n  schemaAnalyzerStatus === 'unavailable' ||\n  vectorEngineStatus === 'unavailable'\n);\n\nconst systemStatus = allOperational ? 'operational' : (anyUnavailable ? 'service_outage' : 'degraded');\n\nreturn {\n  json: {\n    status: systemStatus,\n    service: 'TechnicIA Document Ingestion',\n    version: '2.0.0',\n    timestamp: new Date().toISOString(),\n    microservices: {\n      documentProcessor: documentProcessorStatus,\n      schemaAnalyzer: schemaAnalyzerStatus,\n      vectorEngine: vectorEngineStatus\n    }\n  }\n};"
      },
      "name": "Check Microservices Health",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [420, 520]
    },
    {
      "parameters": {
        "content": "={{ JSON.stringify($json) }}",
        "responseProperties": {
          "properties": [
            {
              "name": "responseCode",
              "value": "={{ $json.status === 'operational' ? 200 : ($json.status === 'degraded' ? 503 : 500) }}"
            }
          ]
        }
      },
      "name": "Return Health Status",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [600, 520]
    },
    {
      "parameters": {
        "path": "document/:documentId/status",
        "responseMode": "onReceived",
        "options": {},
        "httpMethod": "GET"
      },
      "name": "Document Status Endpoint",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [240, 700],
      "webhookId": "document-status"
    },
    {
      "parameters": {
        "url": "={{ 'http://vector-engine:8003/api/document/' + $parameter.documentId + '/status' }}",
        "method": "GET",
        "options": {
          "allowUnauthorizedCerts": true,
          "response": {
            "response": {
              "fullResponse": true
            }
          }
        }
      },
      "name": "Get Document Status",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 2,
      "position": [420, 700]
    },
    {
      "parameters": {
        "content": "={{ JSON.stringify($json.body || {error: 'Unable to retrieve document status'}) }}",
        "responseProperties": {
          "properties": [
            {
              "name": "responseCode",
              "value": "={{ $json.statusCode || 200 }}"
            }
          ]
        }
      },
      "name": "Return Document Status",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [600, 700]
    }
  ],
  "connections": {
    "Document Upload Webhook": {
      "main": [
        [
          {
            "node": "Validate Document",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Document": {
      "main": [
        [
          {
            "node": "Document Valid?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Document Valid?": {
      "main": [
        [
          {
            "node": "Write Binary File",
            "type": "main",
            "index": 0
          },
          {
            "node": "Config Parameters",
            "type": "main",
            "index": 0
          },
          {
            "node": "Send Response Success",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Send Response Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Config Parameters": {
      "main": [
        [
          {
            "node": "Prepare Document Processing",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Write Binary File": {
      "main": [
        [
          {
            "node": "Prepare Document Processing",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Document Processing": {
      "main": [
        [
          {
            "node": "Document Processor Service",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Document Processor Service": {
      "main": [
        [
          {
            "node": "Process Document Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Document Results": {
      "main": [
        [
          {
            "node": "Schema Analyzer Service",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Schema Analyzer Service": {
      "main": [
        [
          {
            "node": "Process Schema Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Schema Results": {
      "main": [
        [
          {
            "node": "Vector Engine Service",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Vector Engine Service": {
      "main": [
        [
          {
            "node": "Prepare Final Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Final Response": {
      "main": [
        [
          {
            "node": "Notify Frontend",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Health Check Endpoint": {
      "main": [
        [
          {
            "node": "Check Microservices Health",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Microservices Health": {
      "main": [
        [
          {
            "node": "Return Health Status",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Document Status Endpoint": {
      "main": [
        [
          {
            "node": "Get Document Status",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Document Status": {
      "main": [
        [
          {
            "node": "Return Document Status",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  }
}